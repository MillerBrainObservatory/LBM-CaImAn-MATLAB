%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Volumetric processing script
% process_MAxiMuM_volume.m
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear
close all;
clc
    
addpath(genpath('/raid0/PROCESSING_SCRIPTS/Tiff_Processing/'))
addpath(genpath('/raid0/PROCESSING_SCRIPTS/Segmentation_Routines/CaImAn-MATLAB-master/'))

path = '/vmd/jeff_demas/MAxiMuM_data/20190918b/';
file = 'mh51_0p6mm_FOV_200mW_100_600um_depth_STIMULUS_3min_m3_00001_processed';
% file = 'mh52_0p6mm_FOV_truncated_STIMULUS_processed';

%% Load data
disp('Loading data from file...')
Y = load([path file '.mat'],'vol');
Y = Y.vol;
disp('Data loaded.')

%% Memory mapping
tmppath = '/raid0/MATLAB_TMP/';
tmpfname = 'tmp';

sizY = size(Y);
Yr = reshape(Y,sizY(1)*sizY(2)*sizY(3),sizY(4));
nY = min(min(Yr));

disp('Saving data to temporary memory mapped file in local folder...')
savefast([tmppath tmpfname '.mat'],'Yr','Y','nY','sizY');
data = matfile([tmppath tmpfname '.mat'],'Writable',true);
disp('Data memory mapped.')

[cY,~,~] = motion_metrics(Y,[10,10,10,10,2,2]);

clear Y Yr nY

%% Motion correction
% Normal normcorre routine derived from the same pipeline Sigi initially
% provided

OD = load([path file '.mat'],'pixel_resolution');
pixel_resolution = OD.pixel_resolution;
clear OD

addpath(genpath('motion_correction/'))

disp('Beginning motion correction...')
gcp;

% mc_filename = fullfile(path,[file,'_mc.h5']);
% if exist(mc_filename, 'file') == 2
% Rigid motion correction using NoRMCorre algorithm:
options_rigid = NoRMCorreSetParms(...
    'd1',sizY(1),...
    'd2',sizY(2),...
    'd3',sizY(3),...
    'bin_width',24,...          % Bin width for motion correction
    'max_shift',[round(40/pixel_resolution),round(40/pixel_resolution),2],...     % Max shift in px
    'us_fac',20,...
    'init_batch',120,...        % Initial batch size
    'correct_bidir',false,...    % Do not correct bidirectional scanning
    'output','memmap'...
    );
[M1,shifts1,~,~] = normcorre_batch(data,options_rigid);

% Compute template from the lowest motion frames:
shifts_r = squeeze(cat(3,shifts1(:).shifts));
shifts_v = movvar(shifts_r,24,1);
[~,minv_idx] = mink(shifts_v,120,1);
best_idx = unique(reshape(minv_idx,1,[]));
template_good = mean(M1(:,:,:,best_idx),4);

[cM1,~,~] = motion_metrics(M1,[10,10,10,10,2,2]);

clear M1

% Non-rigid motion correction using NoRMCorre algorithm:    
options_nr = NoRMCorreSetParms(...
    'd1',size(vol,1),...
    'd2',size(vol,2),...
    'd3',size(vol,3),...
    'bin_width',24,...          % Bin width for motion correction
    'max_shift',[round(40/pixel_resolution),round(40/pixel_resolution),2],...     % Max shift in px
    'us_fac',20,...
    'init_batch',120,...        % Initial batch size
    'correct_bidir',false,...   % Do not correct bidirectional scanning
    'mem_batch_size',120,...
    'output_type','memmap'...
    );

[data,shifts2,~,~] = normcorre_batch(data,options_nr,template_good);             

% Calculate motion correction metrics:

T = length(cY);
shifts_r = squeeze(cat(3,shifts2(:).shifts));

% Plot and save motion correction metrics:
figure(11);
    ax1 = subplot(411); plot(1:T,cY,1:T,cM1); legend('raw data','rigid'); title('Correlation coefficients')
            set(gca,'Xtick',[])
    ax2 = subplot(412); plot(shifts_r(:,1),'k'); title('Displacements along x (px)')
            set(gca,'Xtick',[])
    ax3 = subplot(413); plot(shifts_r(:,2),'k'); title('Displacements along y (px)')
            xlabel('timestep')
    ax4 = subplot(414); plot(shifts_r(:,3),'k'); title('Displacements along z (px)')
            xlabel('timestep')
    linkaxes([ax1,ax2,ax3,ax4],'x')
% sdf(11,'sigi2')
try
    saveas(gcf,[path file,'_motioncorr.pdf']);  
    close all;
catch
    disp('export_fig failed.');
end

%% Begin CaImAn

OD = load([path file '.mat'],'stimFlag','volume_rate','pixel_resolution');
stimFlag = OD.stimFlag;
volume_rate = OD.volume_rate;
pixel_resolution = OD.pixel_resolution;

if stimFlag
    OD = load([path file '.mat'],'imaging_time','stim_both','stim_som','stim_vis','vel');
    imaging_time = OD.imaging_time;
    stim_both = OD.stim_both;
    stim_som = OD.stim_som;
    stim_vis = OD.stim_vis;
    vel = OD.vel;
end

clear OD

gcp;                            % start cluster
addpath(genpath('CaImAn-MATLAB-master/CaImAn-MATLAB-master/utilities'));
addpath(genpath('CaImAn-MATLAB-master/CaImAn-MATLAB-master/deconvolution'));

% Give access to CaImAn files
addpath('CaImAn-MATLAB-master/CaImAn-MATLAB-master')
addpath('CaImAn-MATLAB-master/CaImAn-MATLAB-master/utilities/')
addpath('CaImAn-MATLAB-master/CaImAn-MATLAB-master/use_cases/')
addpath('CaImAn-MATLAB-master/CaImAn-MATLAB-master/tests/')
addpath('CaImAn-MATLAB-master/CaImAn-MATLAB-master/Sources2D/')
addpath('CaImAn-MATLAB-master/CaImAn-MATLAB-master/endoscope/')
addpath('CaImAn-MATLAB-master/CaImAn-MATLAB-master/docs/')
addpath('CaImAn-MATLAB-master/CaImAn-MATLAB-master/deconvolution/')
addpath('CaImAn-MATLAB-master/CaImAn-MATLAB-master/3D/')
addpath('CaImAn-MATLAB-master/CaImAn-MATLAB-master/@CNMF/')

switch pixel_resolution
case 1
    tau = [7.5,7.5,1];
    dist = 1.25;
case 3
    tau = [3,3,2];
    dist = 1.25;
case 5
    tau = [2,2,2];
    dist = 1.5;
end

% CaImAn settings
K = 500;  % number of components (neurons) to be found
merge_thresh = 0.8; % threshold for merging
min_SNR = 1.5; % minimum SNR
space_thresh = 0.2; % threhsold for selection of neurons by space
time_thresh = 0.2;
sz = 0.1; % IF FOOTPRINTS ARE TOO SMALL, CONSIDER sz = 0.1
mx = ceil(pi.*(1.25.*tau(1)).^2);
mn = floor(pi.*(round(tau(1).*0.5)-1).^2); % SHRINK IF FOOTPRINTS ARE TOO SMALL

p = 2;

% patch set up
sizY = data.sizY;
patch_size = round([100,100,30]./pixel_resolution);
overlap = round([15,15,0]./pixel_resolution);
patches = construct_patches(sizY(1:end-1),patch_size,overlap);

options = CNMFSetParms(...   
'd1',sizY(1),'d2',sizY(2),'d3',sizY(3),...                         % dimensionality of the FOV
'deconv_method','constrained_foopsi',...    % neural activity deconvolution method21
'temporal_iter',3,...                       % number of block-coordinate descent steps 
'maxIter',15,...                            % number of NMF iterations during initialization
'spatial_method','regularized',...          % method for updating spatial components
'df_prctile',10,...                         % take the median of background fluorescence to compute baseline fluorescence 
'p',p,...                                   % order of AR dynamics    
'gSig',tau,...                              % half size of neuron
'merge_thr',merge_thresh,...                % merging threshold  
'time_thresh',time_thresh,...
'nb',1,...                                  % number of background components  
'gnb',3,...
'min_SNR',min_SNR,...                       % minimum SNR threshold
'space_thresh',space_thresh ,...            % space correlation threshold
'decay_time',0.5,...
'search_method','ellipse',...
'dist', dist, ...                              % expansion factor of ellipse (default: 3)
'max_size_thr',mx,...                       % maximum size of each component in pixels (default: 300)
'min_size_thr',mn,...                       % minimum size of each component in pixels (default: 9)
'tsub',1,...
'ssub',1,...
'size_thr', sz, ...
'min_size', round(tau(1)), ...           % minimum size of ellipse axis (default: 3)
'max_size', 2*round(tau(1)), ....             % maximum size of ellipse axis (default: 8)
'cl_thr',0.8,...
'fr', fr./tsub);%,...
% 'robust_std','true');

% [P,Y] = preprocess_data(data.Y,p);
% [Ain,Cin,bin,fin,center] = initialize_components(Y,K,tau,options,P);  % initialize

data.nY = F_dark;
[A,b,C,f,S,P,~,YrA] = run_CNMF_patches(data.Y,K,patches,tau,p,options);

% Cn =  correlation_image(data_d); 

% Classify components:
%         rval_space = classify_comp_corr(data_d,A,C,b,f,options);
[rval_space,rval_time,max_pr,sizeA,keep0,~] = classify_components_jeff(data,A,C,b,f,YrA,options);

mod_rval = rval_space(keep0);

[rbins,~] = histcounts(mod_rval,0:0.025:1);
cs = fliplr(cumsum(fliplr(rbins)));
x = 0.025:0.025:1;
ft = fit(x',cs','smoothingspline','smoothingparam',0.999);
[~,ddft] = differentiate(ft,x);
[~,indR] = min(ddft);
rValP = x(indR);

figure
plot(x,cs)
hold on
plot(x(indR),cs(indR),'rx','MarkerSize',10)
xlabel('Spatial threshold')
ylabel('Number of neurons allowed')

rVal = 0.6;

ind_corr = (rval_space > rVal) & keep0;                     

% Event exceptionality:
fitness = compute_event_exceptionality(C+YrA,options.N_samples_exc,options.robust_std);
ind_exc = (fitness < options.min_fitness);
%         ind_exc = ones(size(fitness));
%         Cmean = mean(mean(C));
%         Cmax = max(C,[],2);
%         ind_exc(Cmax>5*Cmean) = 1;
%         
% Select components:
keep = ind_corr & ind_exc;

% Display kept and discarded components
A_keep = A(:,keep);
C_keep = C(keep,:);

% Re-merge components
% Yr = reshape(vol,d,T);
% [Am,Cm,K_m,merged_ROIs,Pm,Sm] = merge_components(Yr,A_keep,b,C_keep,f,P,S,options);

% Refine estimates excluding rejected components
%         [A2,b2,C2] = update_spatial_components(Yr,Cm,f,[Am,b],Pm,options);
%         [C2,f2,P2,S2,YrA2] = update_temporal_components(Yr,A2,b2,C2,f,Pm,options);

try
    [A_or,C_or,S_or,P_or] = order_ROIs(A_keep,C_keep,S,P); % order components
    K = size(A_or,2);
catch
    A_or = A_keep;
    C_or = C_keep;
    S_or = S;
    P_or = P;
    K = size(A_or,2);
end

% [found_traces,Df] = get_traces(Yr,A_or,C_or,b,f,d1,d2,size(C_or,2),options);
% DF = Df*ones(1,size(data_d,3));
% 
% found_traces = (found_traces)./DF;